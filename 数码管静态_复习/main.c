#include <reg52.h>
#include <intrins.h>
#define uint unsigned int
#define uchar unsigned char

uint wenumber;
sbit DU = P2 ^ 6;
sbit WE = P2 ^ 7;

void delay(uint z)
{
    uint x, y;
    for (x = z; x > 0; x--)
        for (y = 144; y > 0; y--)
            ;
}

void main()
{

    while (1)
    {
        wenumber = 0xfe; // 位选初始变量

        /*----------------------------*/
        WE = 1;
        P0 = 0xff;
        WE = 0;
        // 不选中所有数码管，0xff负责清除之前可能存在的P0其他状态。
        /*----------------------------*/
        DU = 1;
        P0 = 0x6d;
        DU = 0;
        // 在段选中输入数字”5“的字形码。
        /*----------------------------*/
        WE = 1;
        P0 = wenumber;
        WE = 0;
        // 选中第一个数码管。
        delay(1);
        /*----------------------------*/
        // 延迟1毫秒，第一个数码管的显示流程结束。

        wenumber = _crol_(wenumber, 1); // 位选变量调整，预选中第二个数码管。

        /*----------------------------*/
        WE = 1;
        P0 = 0xff;
        WE = 0;
        // 不选中所有数码管，0xff负责清除之前可能存在的P0其他状态。
        /*----------------------------*/
        DU = 1;
        P0 = 0x5b;
        DU = 0;
        // 在段选中输入数字”2“的字形码。
        /*----------------------------*/
        WE = 1;
        P0 = wenumber;
        WE = 0;
        // 选中第二个数码管。
        /*----------------------------*/
        delay(1);
        /*----------------------------*/
        // 延迟1毫秒，第二个数码管的显示流程结束。

        wenumber = _crol_(wenumber, 1); // 位选变量调整，预选中第三个数码管。

        /*----------------------------*/
        WE = 1;
        P0 = 0xff;
        WE = 0;
        // 不选中所有数码管，0xff负责清除之前可能存在的P0其他状态。
        /*----------------------------*/
        DU = 1;
        P0 = 0x3f;
        DU = 0;
        // 在段选中输入数字”0“的字形码。
        /*----------------------------*/
        WE = 1;
        P0 = wenumber;
        WE = 0;
        // 选中第三个数码管。
        /*----------------------------*/
        delay(1);
        /*----------------------------*/
        // 延迟1毫秒，第三个数码管的显示流程结束。

        wenumber = _crol_(wenumber, 1); // 位选变量调整，预选中第四个数码管。

        /*----------------------------*/
        WE = 1;
        P0 = 0xff;
        WE = 0;
        // 不选中所有数码管，0xff负责清除之前可能存在的P0其他状态。
        /*----------------------------*/
        DU = 1;
        P0 = 0x06;
        DU = 0;
        // 在段选中输入数字”1“的字形码。
        /*----------------------------*/
        WE = 1;
        P0 = wenumber;
        WE = 0;
        // 选中第四个数码管。
        /*----------------------------*/
        delay(1);
        // 延迟1毫秒，第四个数码管的显示流程结束。

        wenumber = _crol_(wenumber, 1); // 位选变量调整，预选中第五个数码管。

        /*----------------------------*/
        WE = 1;
        P0 = 0xff;
        WE = 0;
        // 不选中所有数码管，0xff负责清除之前可能存在的P0其他状态。
        /*----------------------------*/
        DU = 1;
        P0 = 0x4f;
        DU = 0;
        // 在段选中输入数字”3“的字形码。
        /*----------------------------*/
        WE = 1;
        P0 = wenumber;
        WE = 0;
        // 选中第五个数码管。
        /*----------------------------*/
        delay(1);
        // 延迟1毫秒，第五个数码管的显示流程结束。

        wenumber = _crol_(wenumber, 1); // 位选变量调整，预选中第六个数码管。

        /*----------------------------*/
        WE = 1;
        P0 = 0xff;
        WE = 0;
        // 不选中所有数码管，0xff负责清除之前可能存在的P0其他状态。
        /*----------------------------*/
        DU = 1;
        P0 = 0x06;
        DU = 0;
        // 在段选中输入数字”1“的字形码。
        /*----------------------------*/
        WE = 1;
        P0 = wenumber;
        WE = 0;
        // 选中第六个数码管。
        /*----------------------------*/
        delay(1);
        // 延迟1毫秒，第六个数码管的显示流程结束。

        wenumber = _crol_(wenumber, 1); // 位选变量调整，预选中第七个数码管。

        /*----------------------------*/
        WE = 1;
        P0 = 0xff;
        WE = 0;
        // 不选中所有数码管，0xff负责清除之前可能存在的P0其他状态。
        /*----------------------------*/
        DU = 1;
        P0 = 0x66;
        DU = 0;
        // 在段选中输入数字”4“的字形码。
        /*----------------------------*/
        WE = 1;
        P0 = wenumber;
        WE = 0;
        // 选中第七个数码管。
        /*----------------------------*/
        delay(1);
        // 延迟1毫秒，第七个数码管的显示流程结束。
    }
}
/*
有些问题需要注意：
1.为什么程序的主体必须写在死循环while(1)中；
    2.为什么必须要延迟； 以下是我的个人理解：
    在最开始的程序中，我对位选和段选都进行了断码清除操作，但最后的程序只对位选进行了断码清除，为什么只要对位选进行断码清除呢？我之所以对延迟操作存在疑惑，是因为我认为，
    我对位选和段选都进行了断码清除处理，在断码清除之后数码管根本没有选中，它亮都不会亮，怎么会造成视觉残留效应呢？可实际情况是它根本显示不了数字，如果说不能延迟太长是
    因为数码管其实不会同时亮起，人眼之所以看到数码管同时亮起是因为延迟效果较短，人眼没有反应过来，大脑误以为数码管是同时亮起的，

    写动态数码管的程序一定要先写段选再写位选，为什么呢，因为如果你先写位选，就一定会改变P0端口的状态，而此时段选开关不一定处于关闭状态，可能段选寄存器也 会接收此时的
    P0口信息，这样数码管就会显示乱码，让我们看看，第一个版本的代码中，我让P0口等于0xfe，如果按照这种假说来分析，第一个数码管应该只有a段不会亮，实际情况与理论分析吻合，
    说明这种假说确实具有一定道理， 为什么我要强调“一定”呢，在代码的最终版本中，先让P0等于0xff，这样做的道理是进行断码清除，可如果按照之前的道理来讲，第一个数码管应该
    所有段位全亮，可在在线仿真过程中，并没有出现这种情况，此时实际情况和理论分析是不吻合的，不过这并不能证明我的假说完全错误，至少第一种情况是吻合的，不不不，我的分析
    存在不对的地方，怎么说呢，我之前混淆了一个很重要的概念，数码管显示什么是依据段选寄存器里的数据而不是P0口的数据，（这段话不准确，动态显示有两种方法：段 位 段   和
    位 段 位）

    让我们分析一下在最开始的代码版本中为什么会出现循环移位的现象，我们姑且认为上面的假说是正确的，首先我们让P0口等于0xff，准备让0xff的信息传递到位选寄存器，从而取消
    所有数码管的选中，但这里写的明显有问题，我只让P0口等于0xff但并没有把这个信息传递到位选寄存器中，然后我开启了段选寄存器，此时P0口还是0xff，于是段选寄存器此时储存
    的信息是0xff，接着我更改了P0口状态，让其等于0xfe意为选中第一个数码管，此时段选寄存器可能也处在开启状态，于是段选寄存器中也储存了0xfe的信息，此时，位选寄存器和段
    选寄存器中的信息都是0xfe，位选寄存器是0xfe意味选中第一个数码管，而段选寄存器中的0xfe意味数码管除了a段其他都亮，所以此时第一个数码管除了a段其他都显示 ，然后我打
    开了段选寄存器，通过循环移位的方式将wenumber由0xfe变为0xfd,
    为选中第二个数码管做准备，之后我关闭了位选寄存器，之后我之后我再次改变了P0口的状态，使P0口变为0，很
    明显，此举是为了对段选做断码清除处理，不过犯了之前的错误，我只让P0口等于0，没有把信息传递到段选寄存器中，然后我打开了段选寄存器，此时段选寄存器中的信息由0xfe变
    为了0，现在位选寄存器中的信息是0xfe，段选寄存器中的信息是0，不会有任何数码管亮起，接着我再次改变了P0口的状态，让P0口变为了0x6d,
    也就是数字“5”的字形码，就这样段
    选寄存器由之前的0xfe变为了0x6d,
    现在位选寄存器中的信息是0xfe，段选寄存器 的信息是0x6d, 第一个数码管显示了数字  “5”，然后我关闭了段选寄存器，让P0口变为0xff,
    很明显，此举的目的是对位选做断码清除处理，但和之前一样我只让P0口变为0xff，而没 有把P0口的信息传递到位选寄存器中，接着我打开了位选寄存器，于是位选寄存器中信息就
    由0xfe变为了0，此时位选寄存器信息是0，段选寄存器信息是0x6d，不会有任何数码管显示， 接着我让P0口变为wenumber，即0xfd，意为选中第二个数码管 ，于是位选寄存器由0
    变为了0xfd，此时位选寄存器是0xfd,
    段选寄存器是0x6d，于是第二个数码管显示了数字“5”，这就是数码管显示数字似乎循环移位的原因。

#include <reg52.h>
#include <intrins.h>

#define uint unsigned int

    uint wenumber;
uint flag;
uint arr[7] = {0x6d, 0x5b, 0x3f, 0x06, 0x4f, 0x06, 0x66};

sbit DU = P2 ^ 6;
sbit WE = P2 ^ 7;

void main()
{
    while (1)
    {
        wenumber = 0xfe;
        for (flag = 0; flag < 7; flag++)
        {
            P0 = 0;
            DU = 1;
            DU = 0;

            P0 = wenumber;
            WE = 1;
            WE = 0;

            P0 = arr[flag];
            DU = 1;
            DU = 0;

            if (6 == flag)
                break;

            wenumber = _crol_(wenumber, 1);
        }
    }
}
*/